# Git: подстраховка для ваших проектов

Я очень хорошо помню 10 января 2010 года: в этот день мы потеряли всю историю 
изменений нашего проекта. Мы использовали Subversion в качестве системы контроля 
версий, которая сохраняла историю нашего проекта в центральном репозитории на 
сервере. К тому же, мы регулярно выполняли резервное копирование данных с 
сервера — по крайней мере, мы так думали. Сервер сломался и все резервные копии 
оказались нерабочими. Наш проект не был утерян бесследно, чего не скажешь о всей 
истории изменений.

Вскоре после поломки сервера мы перешли на Git. Управление версиями мне всегда 
казалось пыткой; оно было слишком сложным и недостаточно удобным, чтобы я мог 
оценить его ценность, тем не менее я выполнял его как нелюбимую обязанность. 
Однако прошло некоторое время работы с новой системой и я начал понимать, какой 
на самом деле полезной может быть Git. С того времени она не раз спасала мне шею. 

В этой статье я постепенно расскажу о том, каким образом Git может помочь вам 
избежать ошибок и как провести восстановление, если они все-таки имели место. 

## Каждому члену команды по резервной копии

Поскольку Git является распределённой системой управления версиями, каждый член 
нашей команды, который клонировал проект (или же «создал её рабочую копию», если 
вы привыкли к терминологии Subversion), автоматически создаёт на своём диске 
резервную копию. Эта резервная копия содержит самую последнюю версию проекта, а 
также полную историю его изменений.

Это значит, что если локальная машина разработчика или даже наш центральный 
сервер когда-нибудь снова сломаются (и по какой-либо причине резервная копия 
опять не будет работать), мы можем вернуться в состояние рабочей готовности за 
считанные минуты: любой локальный репозиторий с диска члена команды — это всё, 
что нужно для полноценной функциональной замены утерянных данных.

## Ветки позволяют разделить то, что нужно разделить

Когда мои более подкованные в техническом плане коллеги рассказывали мне 
насколько «крутым» является использование веток в Git, я не мог тут же 
отреагировать бурным всплеском радости. Во-первых, должен признать, что я не 
особо понимал в чём состоит преимущество использования веток. И во-вторых, после 
работы с Subversion, я очень живо помнил насколько сложной и склонной к ошибкам 
являлась эта процедура. Исходя из плохих воспоминаний, работа с ветками 
заставляла меня нервничать и я старался избегать её при первой возможности.

Потребовалось довольно длительное время прежде чем я понял, что в Git разделение 
на ветки и их слияние работают совершенно иначе, чем в большинстве других систем, 
особенно если говорить о простоте в использовании. Итак, если вы постигли 
концепцию веток на основе другой системы управления версиями (вроде Subversion), 
советую вам забыть все свои предыдущие знания и начать с ноля. Давайте начнём с 
того, почему вообще ветки настолько важны. 

### Почему ветки важны

В то время, когда я *еще не* использовал ветки, работа над новыми компонентами 
была сплошным хаосом. По большому счёту, у меня был выбор между двумя одинаково 
никудышными вариантами организации рабочего процесса:

(a) Я уже успел понять, что создание небольших гранулированных коммитов с 
небольшим количеством изменений — хорошая привычка, когда имеешь дело с системой 
управления версиями. Однако, если я делал так в процессе разработки нового 
компонента, каждый коммит смешивал мой полусырой компонент с основной кодовой 
базой до тех пор, пока я не закончу. Мои коллеги были не в восторге от того, что 
из-за моего незаконченного компонента в проекте появлялись ошибки.

(б) Чтобы избежать перемешивания незаконченной работы с другими вещами (моего 
авторства или авторства моих коллег), я работал над компонентом в отдельном 
месте. Я создавал копию папки проекта, с которой мог работать, никому не мешая, 
и коммитил мою разработку после её завершения. Однако внесение всех изменений в 
самом конце работы вело к тому, что у меня получался один огромный раздутый 
коммит, содержащий все изменения. Ни мои коллеги, ни я глядя на него позже не 
могли разобраться, что именно было изменено в этом коммите. 

Я постепенно пришёл к осознанию того, что мне придётся освоить ветки если я хочу 
улучшить свой процесс разработки. 

### Работа в различных контекстах

Любой проект предусматривает множество контекстов, в которых ведётся работа; 
каждый компонент, исправление ошибки, эксперимент или альтернатива вашему 
продукту — это своего рода контекст сам по себе. Его можно рассматривать как 
отдельный «тематический раздел», чётко отграниченный от других таких разделов.

Если такие тематические разделы не отделять друг от друга с помощью веток, 
неизбежно повышается риск проблем. Перемешивание тематических разделов в одном 
контексте:

* усложняет контроль над ними — а при большом количестве тематических разделов 
он становится почти невозможным;
* усложняет откат какого-либо действия, которое привело к ошибке, так как оно 
уже смешалось со слишком большим количеством других вещей;
* не вдохновляет людей на эксперименты, так как после смешивания 
экспериментального кода с основным кодом проекта, становится очень трудно 
извлечь его из репозитория.

Использование веток вселило в меня уверенность, что я не могу напортачить. Если 
что-то идёт не так, я могу вернуться назад, отменить действие, начать с ноля или 
сменить контекст.

### Основы использования веток

Использование веток в Git подразумевает использование всего лишь горстки команд. 
Давайте для ознакомления рассмотрим основной рабочий процесс.

Чтобы создать новую ветку на основании текущего состояния, всё что вам нужно 
сделать — это выбрать имя и выполнить одну команду в командной строке. Допустим, 
что мы хотим начать работу над новой версией контактной формы, следовательно 
создадим новую ветку под названием «contact-form»:

    $ git branch contact-form

Если выполнить команду `git branch` не указывая имя ветки, получим список всех 
веток, которые есть в наличии на данный момент (а ключ «-v» предоставит немного 
дополнительной информации):

    $ git branch -v

![Скриншот][Экран Git, на котором отображены текущие ветки контактной формы.]

Вы наверное заметили маленькую звёздочку напротив ветки под названием «master». 
Она обозначает ветку, которая на данный момент является активной. Итак, перед 
тем, как начать работу над нашей контактной формой, нам нужно сделать её 
активным контекстом:

    $ git checkout contact-form

Теперь Git сделала эту ветку нашим текущим рабочим контекстом. (На языке Git это 
называется «HEAD branch»). Все изменения и любой коммит, который мы совершим с 
текущего момента, будут влиять только на этот контекст — остальные контексты 
останутся нетронутыми. Если мы захотим переключить контекст на другую ветку, мы 
просто снова используем команду `git checkout`.

Если мы хотим добавить изменения из одной ветки в другую, мы можем выполнить их 
«слияние» в текущий рабочий контекст. Представьте, что некоторое время мы 
работали над нашим компонентом «contact-form», а теперь хотим добавить эти 
изменения в ветку «master». Всё, что нам нужно сделать — это переключиться на 
эту ветку и вызвать `git merge`:

    $ git checkout master
    $ git merge contact-form

### Использование веток

Я вам настоятельно советую активно использовать ветки в ежедневной работе. Ветки — 
это одна из ключевых концепций, вокруг которых был построен Git. Они требуют 
минимальных затрат и изумительно просты в создании и управлении. Существует 
[предостаточное количество ресурсов][1], если вы готовы узнать больше о том, как 
их использовать.

## Отмена действий

За годы работы программистом я твёрдо усвоил одну вещь: ошибки случаются вне 
зависимости от того сколько у вас опыта. Их нельзя избежать, однако можно 
запастись инструментами, которые помогут их откатить.

Одна из наиболее замечательных возможностей Git состоит в том, что отменить 
можно практически любое действие. Это даёт мне достаточную уверенность, чтобы 
экспериментировать без тени страха, ведь пока что мне так и не удалось сломать 
что-то настолько, чтобы это *действительно* нельзя было исправить. 

### Внесение поправок в последний коммит

Даже если вы очень аккуратно готовите свои коммиты, очень легко забыть указать 
какое-либо изменение или допустить опечатку в комментарии. С помощью ключа 
`—amend` команды `git commit` Git даёт вам возможность изменить *самый последний* 
коммит, причём очень простым способом. Например, если вы забыли добавить 
какое-либо изменение и допустили опечатку в названии коммита, это можно легко 
исправить:

    $ git add some/changed/files
    $ git commit --amend -m "Комментарий, в этот раз без опечаток"

Вам только нужно помнить одну вещь: коммит, который уже был отослан в удалённый 
репозиторий, изменять нельзя. Уважайте это правило и опция `--amend` станет вашим 
незаменимым маленьким помощником в исправлении последних коммитов.

(Если вас интересует дополнительная информация по опции `--amend`, советую 
почитать [отличное руководство][2] от Ника Куаранто (Nick Quaranto)).

### Отмена локальных изменений

Изменения, для которых не был совершён коммит, называются «локальными». Все 
текущие поправки в вашей рабочей директории являются «локальными» изменениями, 
для которых не был осуществлён коммит.

Сброс этих изменений может потребоваться, когда ваш текущий результат работы 
оказался… скажем, хуже чем то, что было раньше. В Git можно запросто отменить 
локальные изменения и начать сначала с последней версии вашего проекта, для 
которой был совершён коммит.

Если вы хотите восстановить один файл, можете использовать команду `git 
checkout`:

    $ git checkout -- файл/для/восстановления

Не путайте это применение команды `checkout` с переключением между ветками 
(смотрите выше). Если вы используете её с двумя тире и путём к файлу (не 
забывайте пробел!), это приведёт к сбросу изменений в текущем файле, для которых 
не был совершён коммит.

Случаются плохие дни, когда вам может потребоваться сбросить все локальные 
изменения и восстановить весь проект целиком:

    $ git reset --hard HEAD

Это заменит все файлы в вашей рабочей директории на последнюю редакцию, для 
которой был совершён коммит. Так же, как и в случае с командой `checkout`, это 
приведёт к сбросу локальных изменений.

Будьте осторожны с этими операциями: поскольку локальные изменения не были 
зарегистрированы в репозитории, после сброса восстановить их будет невозможно!

### Отмена изменений, для которых был совершён коммит

Само собой, отменить можно не только локальные изменения. Также можно отменить 
некоторые коммиты, когда это необходимо — например, если они привели к ошибке в 
коде.

В общем есть две главные команды, которые позволяют отменить коммит:

**(a) git reset**

![Иллюстрация][Иллюстрация, демонстрирующая как работает команда `git reset`]

Команда `git reset` позволяет буквально вернуться в прошлое. Вы сообщаете к 
какой версии вы хотите вернуться и она восстанавливает именно это состояние — 
отменяя все изменения, которые были осуществлены после этой временной точки. 
Нужно всего лишь сообщить ей хэшевый номер коммита, к которому вы хотите 
вернуться:

    $ git reset --hard 2be18d9

Опция `-—hard` — это наиболее простой и чистый подход, однако она также удаляет 
все локальные изменения в вашей рабочей директории. Так что перед её применением, 
убедитесь, что у вас нет локальных изменений, дорогих сердцу.

**(б) git revert**

![Иллюстрация][Иллюстрация, демонстрирующая как работает команда `git revert`]

Команда `git revert` используется в другой ситуации. Представьте, что у вас есть 
коммит от которого вы бы хотели избавиться, однако коммиты, совершённые после 
него, все ещё актуальны. В таком случае вы не станете использовать команду 
`git reset`, потому что она отменит и эти более поздние коммиты.

Команда `revert` позволяет откатить *последствия* от одного конкретного коммита. 
Она не удаляет какие-либо коммиты в отличие от `git reset`. Напротив, она 
создаёт *новый* коммит, вносящий изменения, противоположные коммиту, который 
подлежит откату. Например, если вы удалили определённую строку кода, `revert` 
создаст новый коммит, добавляющий точно такую же строчку.

Чтобы её использовать, просто укажите SHA1-хеш коммита, который нужно 
откатить: 

    $ git revert 2be18d9

## Поиск ошибок

Когда дело касается поиска ошибок, должен признать, что я убил не один час 
блуждая в потёмках. Часто бывало так, что я был уверен, что пару дней назад все 
*работало*, но не имел понятия *когда же именно* всё пошло наперекосяк. И только 
когда я узнал о `git bisect`, процесс немного ускорился. В виде команды `bisect` 
Git предоставляет инструмент, помогающий обнаружить коммит, с которого началась 
проблема. 

Представьте следующую ситуацию: мы знаем, что текущая версия (с меткой «2.0») 
приведена в негодность. Также мы знаем, что несколько коммитов назад (в версии 
«1.9»), всё было нормально. Ошибка была допущена где-то в этом промежутке.

![Иллюстрация][Иллюстрация, демонстрирующая коммиты между рабочей и нерабочей версиями]

Этой информации уже достаточно, чтобы начать охоту на ошибки с помощью 
`git bisect`:

    $ git bisect start
    $ git bisect bad
    $ git bisect good v1.9

После начала процесса мы сообщили Git, что наш текущий коммит содержит ошибку и 
следовательно является «плохим» («bad»). Затем мы сообщили Git какой из 
предыдущих коммитов точно был рабочим (в качестве параметра для команды 
`git bisect good`).

Git после этого восстанавливает проект *посередине* между заведомо известными 
хорошим и плохим состоянием:

![Иллюстрация][Иллюстрация, демонстрирующая что `bisect` начинает с середины между версиями]

Теперь мы проводим тестирование этой версии (например, с помощью модульного 
тестирования, создания приложения, внедрения в тестовую систему и т.д.), чтобы 
определить является ли это состояние рабочим, или же уже содержит ошибку. Когда 
мы об этом узнаем, снова сообщаем Git о результате с помощью `git bisect bad` 
или `git bisect good`.

Предположим, что мы определили этот коммит как тоже «плохой». Фактически это значит, что ошибка была допущена раньше — и Git опять сократит количество коммитов под вопросом:

![Иллюстрация][Иллюстрация, демонстрирующая как с помощью дополнительных команд `bisect` количество коммитов будет еще сокращено]

Таким образом вы очень быстро определите, где именно была допущена ошибка. Когда 
это произойдёт, выполните `git bisect reset` для окончания охоты за ошибкой и 
восстановления исходного состояния проекта.

## Инструмент, способный спасти вашу шею

Должен признаться, что при первой встрече с Git, любви с первого взгляда у нас 
не получилось. В начале он произвёл такое же впечатление, как и другие системы 
управления версиями, с которыми мне пришлось иметь дело: утомительная в работе и 
бесполезная. Однако со временем работа с ней стала интуитивной и она заслужила 
моё доверие и уверенность.

В конце концов, ошибок нельзя избежать, не важно сколько у нас опыта и насколько 
тщательно мы пытаемся их не допускать. Профессионала от новичка в этом плане 
отличает подготовка: наличие системы, которой можно доверять на случай 
возникновения проблем. Она позволяет всегда держать всё под контролем, особенно 
когда дело касается сложных больших проектов. И, в конечном счёте, она помогает 
повысить свой профессионализм.

## Дополнительные материалы

* Получите [больше информации о внесении поправок, откате действий и сбросе 
коммитов][3].
* Ознакомьтесь с «git bisect» с помощью [этого подробного примера][4].
* Детализированное [введение в ветвление][5].

[1]: http://www.git-tower.com/learn/ebook/command-line/branching-merging/branching-can-change-your-life
[2]: http://gitready.com/advanced/2009/01/12/fixing-broken-commit-messages.html
[3]: http://www.git-tower.com/learn/ebook/command-line/advanced-topics/undoing-things
[4]: http://www.metaltoad.com/blog/beginners-guide-git-bisect-process-elimination
[5]: http://www.git-tower.com/learn/ebook/command-line/branching-merging/branching-can-change-your-life

[Экран Git, на котором отображены текущие ветки контактной формы]: img/branch-listing.jpg "Экран Git, на котором отображены текущие ветки контактной формы"
[Иллюстрация, демонстрирующая как работает команда `git reset`]: img/reset-concept-ru.jpg "Иллюстрация, демонстрирующая как работает команда `git reset`"
[Иллюстрация, демонстрирующая как работает команда `git revert`]: img/revert-concept-ru.jpg "Иллюстрация, демонстрирующая как работает команда `git revert`"
[Иллюстрация, демонстрирующая коммиты между рабочей и нерабочей версиями]: img/bisect-01-ru.jpg "Иллюстрация, демонстрирующая коммиты между рабочей и нерабочей версиями"
[Иллюстрация, демонстрирующая что `bisect` начинает с середины между версиями]: img/bisect-02-ru.jpg "Иллюстрация, демонстрирующая что `bisect` начинает с середины между версиями"
[Иллюстрация, демонстрирующая как с помощью дополнительных команд `bisect` количество коммитов будет еще сокращено]: img/bisect-03-ru.jpg "Иллюстрация, демонстрирующая как с помощью дополнительных команд `bisect` количество коммитов будет еще сокращено"
